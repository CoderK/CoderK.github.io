---
layout: post
title: ES2015 단위 테스트 환경 구축하기
date: 2016-06-04 15:38:14.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- 개발 이야기
tags:
- babel
- es2015
- isparta
- isparta-loader
- karma
- mocha
- test
- webpack
meta:
  _edit_last: '1'
  sociallikes: '1'
  sociallikes_img_url: ''
  _et_post_bg_color: "#ffffff"
  _et_post_bg_layout: dark
  _format_video_embed: ''
  _format_quote_source_name: ''
  _format_quote_source_url: ''
  hits: '1'
author:
  login: jeokrang
  email: jeokrang@gmail.com
  display_name: 개발왕 김코딩
  first_name: 훈민
  last_name: 김
permalink: "/development/1913"
excerpt: "\n\t\t\t\t\t\t"
---

<div class="se_component se_paragraph default">
<div class="se_sectionArea">
<div class="se_editArea">
<div class="se_viewArea se_ff_nanumgothic">
<div class="se_editView">
<p class="se_textView se_fs_T3">es2015으로 넘어가면서 JavaScript에 많은 변화가 생겼다. 관용적으로 사용하던 패턴들은 이제 공식 스펙으로 변했고, 실수하기 쉬운 변수 스코프 문제, 번거로운 값 재할당이나 기본 값 정의와 같이 빈번하게 해야하는 귀찮은 작업을 더 간결하게 처리할 수 있는 문법이 새롭게 등장했다. 든 자리는 몰라도 난 자리는 안 다고, es2015의 장점은 사용할 때보다, 사용하다 사용할 수 없는 환경에 놓였을 때 더 강하게 느껴진다.</p>
<p>아직 브라우저의 지원이 부족하고, IE가 대표하는 구형 브라우저까지 대응해야 하는 국내 개발자들에게 es2015는 그저 그림의 떡처럼 보일지도 모르겠다. 다행히 훌륭한 능력자들께서 우리를 어여삐 여기시어 babel이라는 트랜스파일 도구를 만들어주셨으니 그저 감사할 따름. 물론 es2015를 순수 날것으로 활용하지 못하기에 코드를 트랜스파일하는 데 필요한 몇 가지 복잡한 설정을 잡아줘야 하는 건 옥에 티다.</p>
<p>단위 테스트 환경도 마찬가지인지라 es2015로 트랜스파일한 코드를 테스트하려면 귀찮은 설정을 해야 한다. 단위 테스트 실행 환경에 트랜스파일 전처리 과정을 집어넣어야 하고, 원시 코드와 목적 코드를 연결해줄 소스 맵을 적용해야 하고, 원시 코드를 대상으로 커버리지를 측정하도록 테스트 실행 과정에 보정 단계를 추가해야 한다.</p>
<p>아직까지 웹 프런트엔드에서 작성하는 코드를 테스트해야 한다는 생각이 보편적이지 않아서인지는 모르겠으나, 트랜스파일한 코드를 단위 테스트하는 환경을 구축하고 커버리지 리포트 생성하는 과정을 주제로 이야기하는 글은 많지 않다. 해외에는 그나마 간간이 보이는데 국내 자료는 보질 못 했다. 열렬한 테스트 꿈나무로서 뭔가 보여주겠다는 생각에 해외 자료를 몇 개 참고해서 환경 구축을 시도했으나 설명이 불충분한 부분이 많아 삽질을 많이 했다.</p>
</div>
</div>
</div>
</div>
</div>
<div class="se_component se_quotation quotation_line">
<div class="se_sectionArea">
<div class="se_editArea">
<div class="se_viewArea se_fs_T3">
<div class="se_editView">
<div class="se_textView">
<blockquote class="se_textarea"><p>설치하고,<br />
설정하고,<br />
실행하세요.<br />
참 쉽죠?</p></blockquote>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="se_component se_paragraph default">
<div class="se_sectionArea">
<div class="se_editArea">
<div class="se_viewArea se_ff_nanumgothic">
<div class="se_editView">
<div class="se_textView se_fs_T3">
<p class="se_textarea">이게 전부인 글을 굳이 써야 할까 싶지만 내가 겪은 삽질의 과정을 누군가는 밟지 않기를 바라는 마음을 담아 써 보련다.</p>
<p>테스트 환경은 아래의 스택으로 구성할 생각이고, 자세한 설명은 각 섹션에서 한다.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<ul>
<li>npm</li>
<li>babel</li>
<li>webpack</li>
<li>mocha</li>
<li>karma</li>
<li>isparta</li>
</ul>
<h2></h2>
<h2 class="se_textarea">트랜스파일 환경 구축</h2>
<p>기본 es2015 트랜스파일 환경은 babel + webpack을 이용한다. 이제는 너무 유명한 녀석들이라 따로 설명하지는 않겠다.  우선 babel부터 babel-core, babel-loader, babel-preset-es2015를 한 번에 설치한다.</p>
<pre class="lang:sh decode:true" title="babel 설치">npm install -save--dev babel-core babel-loader babel-preset-es2015</pre>
<p>다음은 소스 코드 번들러인 webpack을 설치한다. 혹시 webpack에 궁금하다면 D2 Blog에 올라와 있는 “<a href="http://d2.naver.com/helloworld/0239818">JavaScript 모듈화 도구, webpack</a>“을 참고한다. 개인적으로 좋아한다.</p>
<pre class="lang:sh decode:true">npm install --save-dev webpack</pre>
<p>설치를 모두 마쳤으면 프로젝트 최상위 경로에 webpack.config.js 파일을 만들어 트랜스파일한 코드를 빌드할 환경을 설정한다.</p>
<pre class="lang:js decode:true">const path = require('path');

module.exports = {
    entry: path.resolve(__dirname, 'src/entry.js'),
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    },
    devtool: 'inline-source-map',
    module: {
        loaders: [
            {
                test: /(\.jsx|\.js)$/,
                exclude: /(node_modules)/,
                loader: ['babel-loader'],
                query: {
                    presets: ['es2015']
                }
            }
        ]
    }
};</pre>
<p>위의 설정 중에 entry는 webpack이 의존성 분석을 시작할 진입점을 의미한다. webpack은 진입점을 기준으로 의존성을 분석해서 전체 소스 코드를 하나의 파일로 번들링을 한다.<span class="Apple-converted-space"> </span></p>
<pre class="lang:js decode:true">entry: path.resolve(__dirname, 'src/entry.js'),</pre>
<p>진입점으로 사용할 js 파일을 하나 만들자. 이 과정은 트랜스파일을 제대로 수행하는지를 확인하는 과정으로 테스트 환경 구축과는 크게 관련이 없다. 따라서 entry.js는 아무 내용 없는 빈 파일이어도 상관이 없다. webpack을 실행해서 아래와 같은 화면을 볼 수 있다면 트랜스파일 환경을 성공적으로 구축한 것이다.</p>
<pre class="lang:sh decode:true">KimCoding@gimhunmin-ui-MacBook-Pro  ~/Workspace/test-env  ./node_modules/.bin/webpack
Hash: 4ed74f8638ef157e437e
Version: webpack 1.13.1
Time: 384ms
    Asset     Size  Chunks             Chunk Names
    bundle.js  3.51 kB       0  [emitted]  main
    + 1 hidden modules
 KimCoding@gimhunmin-ui-MacBook-Pro  ~/Workspace/test-env </pre>
<p>여기까지 진행한 후 디렉터리 구조는 이런 모습이다. node_modules는 생략했다.</p>
<pre class="lang:js decode:true ">.
├── dist
│   └── bundle.js
├── package.json
├── src
│   └── entry.js
└── webpack.config.js
</pre>
<p>&nbsp;</p>
<h2 class="se_textarea">mocha + karma 단위 테스트 환경</h2>
<p>트랜스파일 환경을 만들었으니, 이제 단위 테스트 환경을 구축할 차례다. mocha를 설치하면서 chai도 함께 설치한다.<span class="Apple-converted-space"> </span><a href="http://chaijs.com/">chai</a>는 mocha와 함께 많이 쓰이는 단언 라이브러리로 이 녀석을 이용하면 단언을 좀 더 가독성 있게 작성할 수 있다.</p>
<pre class="lang:sh decode:true">npm install --save-dev mocha chai</pre>
<p>babel로 트랜스파일한 코드를 mocha로 테스트할 때 한 가지 아쉬운 점이 있다.  트랜스파일한 코드를 브라우저 환경에서 디버깅하기 어렵다. 트랜스파일하는 전처리 과정이 node 환경에서 이뤄지기 때문이다. 예전에는 런타임 jsx 변환기를 이용해서 코드를 브라우저 환경에서 실행 시점에 변환할 수 있었으나, babel이 6.x 버전으로 넘어가면서 지원을 중단한 상태다.</p>
<p>jspm과 systemjs를 이용하면 런타임 변환 기능을 이용해서 mocha로 작성한 테스트 코드를 브라우저 환경에서 실시간으로 트랜스파일하면서 테스트할 수 있겠다는 생각을 해 본 적은 있지만 아직 시도해보지는 못 했다. 이와 관련한 내용은 다음에 언젠가 좋은 날이 오면 포스팅해보는 걸로 하고.</p>
<p>이야기를 이어가서 이런 이유로 나는 테스트는 mocha로 작성하고 karma를 테스트 러너로 이용하여 브라우저 환경에서 테스트를 실행하는 걸 선호한다. karma를 이용하면 크로스 브라우징 환경에서 단위 테스트를 실행할 수 있고 브라우저 개발자 도구가 제공하는 다양한 기능을 이용하여 디버깅을 할 수 있기 때문이다. 물론 소스맵 적용도 받을 수 있다.</p>
<p>여기까지 약을 팔았으니 karma 관련 패키지를 설치하자. 설치해야 할 패키지가 꽤나 많다.</p>
<pre class="lang:sh decode:true">npm install --save-dev karma karma-chai karma-chrome-launcher karma-mocha karma-mocha-reporter karma-webpack karma-sourcemap-loader</pre>
<p>karma는 다양한 테스트 환경을 플러그인으로 제공한다. 그래서 귀찮지만 필요한 플러그인을 직접 설치하고 설정해줘야만 한다. karma를 설치한 후에는 webpack.config.js를 만들었던 것처럼 karma.conf.js 파일을 만들어서 아래와 같이 테스트 실행 환경을 설정한다.</p>
<pre class="lang:js decode:true ">'use strict';

module.exports = function (config) {
  config.set({
    browsers: ['Chrome'],
    reporters: ['mocha'],
    webpack: {
      devtool: 'inline-source-map',
      module: {
        loaders: [
          {
            test: /(\.js)$/,
            exclude: /(node_modules)/,
            loader: ['babel-loader'],
            query: {
              presets: ['es2015']
            }
          }
        ]
      }
    },
    frameworks: ['mocha'],
    files: [
      './src/**/__tests__/*-test.js'
    ],
    plugins: [
      'karma-chrome-launcher',
      'karma-chai',
      'karma-mocha',
      'karma-sourcemap-loader',
      'karma-webpack',
      'karma-mocha-reporter'
    ],
    preprocessors: {
      './src/**/__tests__/*-test.js': ['webpack']
    },
    coverageReporter: {
      type: 'html',
      dir: 'coverage'
    },
    webpackMiddleware: {
      noInfo: true //please don't spam the console when running in karma!
    },
    singleRun: false
  });
};
</pre>
<p>콘솔에서 카르마를 실행하면 이 파일을 자동으로 읽어들여 초기 환경을 설정한다. 각 설정에 대한 자세한 내용은<span class="Apple-converted-space"> </span><a href="http://karma-runner.github.io/0.13/config/configuration-file.html">공식 문서</a>를 참고한다.</p>
<p>&nbsp;</p>
<h2>샘플 테스트 작성</h2>
<p>지금까지 설정을 제대로 했는지 샘플 테스트를 작성한 후 실행해서 확인하기 위해서 es2015 문법을 사용해서 피보나치수열의 n 번째 값을 구하는 함수를 예제로 만들었다.</p>
<pre class="lang:js decode:true">export default function fibonacci(n) {
    if (n &lt; 2) {
        return n;
    }

    let fibA = 0;
    let fibB = 1;
    let result = 0;

    for(let i = 2; i &lt;= n; i++) {
        result = fibA + fibB;
        fibA = fibB;
        fibB = result;
    }

    return result;
}
</pre>
<p>이 코드를 테스트하는 샘플 테스트 코드는 아래와 같다.</p>
<pre class="lang:js decode:true ">import fibonacci from '../fibonacci.js';
import chai from 'chai';

chai.should();

describe('fibonacci test', () =&gt; {
    it('수열의 첫 번째 값은 0이어야 한다.', () =&gt; {
        // given
        // when
        const actual = fibonacci(0);

        // then
        actual.should.be.eql(0);
    });

    it('수열의 두 번째 값은 1이어야 한다.', () =&gt; {
        // given
        // when
        const actual = fibonacci(1);

        // then
        actual.should.be.eql(1);
    });

    it('수열의 n 번째 값은 n-2번째와 n-1번째 값의 합이어야 한다.', () =&gt; {
        fibonacci(3).should.be.eql(fibonacci(1) + fibonacci(2));
        fibonacci(100000).should.be.eql(fibonacci(99998) + fibonacci(99999));
    });
});</pre>
<p>karma를 실행해서 테스트를 잘 수행하는지 확인한다.</p>
<pre class="lang:js decode:true">./node_modules/.bin/karma start</pre>
<p>아래와 같은 결과가 커맨드 입력창에 로그로 출력되는 걸 볼 수 있다.</p>
<pre class="lang:sh decode:true"> KimCoding@gimhunmin-ui-MacBook-Pro  ~/Workspace/test-env  ./node_modules/.bin/karma start
04 06 2016 10:19:00.646:WARN [karma]: No captured browser, open http://localhost:9876/
04 06 2016 10:19:00.654:INFO [karma]: Karma v0.13.22 server started at http://localhost:9876/
04 06 2016 10:19:00.662:INFO [launcher]: Starting browser Chrome
04 06 2016 10:19:01.960:INFO [Chrome 51.0.2704 (Mac OS X 10.11.5)]: Connected on socket /#X5i0OoD28ZIkdkmaAAAA with id 37092165

START:
  fibonacci test
    ✔ 수열의 첫 번째 값은 0이어야 한다.
    ✔ 수열의 두 번째 값은 1이어야 한다.
    ✔ 수열의 n 번째 값은 n-2번째와 n-1번째 값의 합이어야 한다.

Finished in 0.017 secs / 0.004 secs

SUMMARY:
✔ 3 tests completed</pre>
<div class="se_component se_paragraph default">
<div class="se_sectionArea">
<div class="se_editArea">
<div class="se_viewArea se_ff_nanumgothic">
<div class="se_editView">
<div class="se_textView se_fs_T3">
<p class="se_textarea">자동으로 크롬 브라우저가 열렸다면 놀라지 말자. 그저 지금까지 수행한 과정을 잘 따라왔다는 뜻이다. 자동으로 열린 크롬 브라우저의 개발자 도구를 열어서 보자. 구현 코드의 아무 데나 debugger를 걸어놓고 브라우저를 새로고침하면 sources 탭을 통해 소스맵 적용을 받은 코드를 확인할 수 있다.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div></div>
<div><a href="http://huns.me/wp/wp-content/uploads/2016/06/스크린샷-2016-06-04-오전-10.20.34.png"><img class="aligncenter size-large wp-image-1914" src="{{ site.baseurl }}/assets/images/&#4361;&#4467;&#4367;&#4467;&#4357;&#4469;&#4523;&#4361;&#4451;&#4538;-2016-06-04-&#4363;&#4457;&#4364;&#4453;&#4523;-10.20.34-1024x686.png" alt="스크린샷 2016-06-04 오전 10.20.34" width="960" height="643" /></a></div>
<div></div>
<p>매번 콘솔 창에 긴 명령을 입력하는 게 귀찮다면 npm scripts로 등록해서 태스크를 관리할 수 있다.</p>
<div>
<pre class="lang:js decode:true">"scripts": {
    "test": "node ./node_modules/.bin/karma start",
    "build": "node ./node_modules/.bin/webpack --progress",
},</pre>
</div>
<h2></h2>
<h2>커버리지 리포트 출력하기</h2>
<p>단위 테스트 환경을 만들었으니 다음에는 커버리지 리포트를 생성하는 설정을 추가한다. 단위 테스트 환경은 테스트 런처로 chrome 브라우저를 이용했다. 커버리지를 출력할 때는 헤드리스 브라우저인 phantomjs를 이용할 생각이다.</p>
<p>둘 이상의 브라우저를 이용하여 테스트를 실행하는 환경을 보여주고 싶기도 하고, 보통 커버리지 리포트 생성은 로컬보다는 CI와 연동할 때가 많기에 GUI 브라우저보다는 헤드리스 브라우저를 이용하는 게 더 적절하기 때문이다.</p>
<p>이번에도 필요한 플러그인을 npm 패키지로 설치한다. 지금까지 설치한 npm 패키지가 몇 개인지 가물가물하다. bower로 jquery를 내려받는 걸 보고 깜짝 놀랐던 게 엊그제 같은데.</p>
<div>
<pre class="lang:sh decode:true">npm install --save-dev karma-coverage karma-phantomjs-launcher phantomjs-prebuilt</pre>
</div>
<p>phantomjs 사용에 필요한 플러그인 설정을 karma.conf.js에 추가한다.</p>
<div>
<pre class="lang:js mark:8-9 decode:true">plugins: [
      'karma-chrome-launcher',
      'karma-chai',
      'karma-mocha',
      'karma-sourcemap-loader',
      'karma-webpack',
      'karma-mocha-reporter',
      'karma-coverage',
      'karma-phantomjs-launcher'
    ],</pre>
</div>
<p>아예 테스트와 커버리지 측정을 서로 다른 작업으로 분리하고, 실행할 작업을 의미하는 옵션을 커맨드라인을 통해서 인자로 전달하여, 단위 테스트를 실행할 때와 커버리지 리포트를 출력할 때의 환경을 분기 처리하는 설정을 추가해야겠다.</p>
<div>
<pre class="lang:js decode:true">'use strict';
 
module.exports = function (config) {
    let browsers = ['Chrome'];
    let reporters = ['mocha'];
    let preprocessors = ['webpack', 'sourcemap'];
 
    if (config.coverage) {
        browsers = ['PhantomJS'];
        reporters = ['mocha', 'coverage'];
        preprocessors = ['webpack'];
    }
 
    config.set({
        browsers: browsers,
        reporters: reporters,
        webpack: {
            devtool: 'inline-source-map',
            module: {
                loaders: [
                    {
                        test: /(\.js)$/,
                        exclude: /(node_modules)/,
                        loader: ['babel-loader'],
                        query: {
                            presets: ['es2015']
                        }
                    }
                ]
            }
        },
        frameworks: ['mocha'],
        files: [
            './src/**/__tests__/*-test.js'
        ],
        plugins: [
            'karma-chrome-launcher',
            'karma-chai',
            'karma-mocha',
            'karma-sourcemap-loader',
            'karma-webpack',
            'karma-mocha-reporter',
            'karma-coverage',
            'karma-phantomjs-launcher'
        ],
        preprocessors: {
            './src/**/__tests__/*-test.js': preprocessors
        },
        coverageReporter: {
            type: 'html',
            dir: 'coverage'
        },
        webpackMiddleware: {
            noInfo: true //please don't spam the console when running in karma!
        },
        singleRun: config.coverage
    });
};</pre>
</div>
<p>실행할 때 --coverage라는 인자를 추가로 전달해 커버리지 측정 작업이라는 걸 시스템에 알려준다.</p>
<div>
<pre class="lang:sh decode:true">./node_modules/.bin/karma start --coverage</pre>
</div>
<p><span class="crayon-i">이것도 npm에 scripts로 등록하자.</span></p>
<div>
<pre class="lang:sh decode:true">"scripts": {
    "test": "node ./node_modules/.bin/karma start",
    "coverage": "node ./node_modules/.bin/karma start --coverage",
    "build": "node ./node_modules/.bin/webpack --progress"
  },</pre>
</div>
<p>커버리지 리포트 생성을 실행하면,</p>
<div>
<pre class="lang:js decode:true"> KimCoding@gimhunmin-ui-MacBook-Pro  ~/Workspace/test-env  npm run coverage

&gt; test-env@1.0.0 coverage /Users/KimCoding/Workspace/test-env
&gt; node ./node_modules/.bin/karma start --coverage


START:
04 06 2016 10:41:14.705:INFO [karma]: Karma v0.13.22 server started at http://localhost:9876/
04 06 2016 10:41:14.714:INFO [launcher]: Starting browser PhantomJS
04 06 2016 10:41:15.301:INFO [PhantomJS 2.1.1 (Mac OS X 0.0.0)]: Connected on socket /#BziOyRY-DNLi7BJuAAAA with id 78249631
  fibonacci test
    ✔ 수열의 첫 번째 값은 0이어야 한다.
    ✔ 수열의 두 번째 값은 1이어야 한다.
    ✔ 수열의 n 번째 값은 n-2번째와 n-1번째 값의 합이어야 한다.

Finished in 0.173 secs / 0.051 secs

SUMMARY:
✔ 3 tests completed
 KimCoding@gimhunmin-ui-MacBook-Pro  ~/Workspace/test-env </pre>
</div>
<p>테스트를 수행한 후 커버리지 리포트를 아래 경로에 생성한 것을 확인할 수 있다. 리포트를 생성하는 경로는 karma.conf.js의 옵션을 수정하여 변경할 수 있다.</p>
<div>
<pre class="lang:sh decode:true ">.
├── coverage
│   └── PhantomJS\ 2.1.1\ (Mac\ OS\ X\ 0.0.0)
│       ├── __tests__
│       │   ├── fibonacci-test.js.html
│       │   └── index.html
│       ├── base.css
│       ├── index.html
│       ├── prettify.css
│       ├── prettify.js
│       ├── sort-arrow-sprite.png
│       └── sorter.js</pre>
</div>
<p>coverage/PhantomJS…(생략)/index.html 파일을 브라우저로 열어서 상세 리포트를 볼 수 있다. 리포트를 열어보자.</p>
<p>두근, 두근.</p>
<div><a href="http://huns.me/wp/wp-content/uploads/2016/06/스크린샷-2016-06-04-오전-10.43.32.png"><img class="aligncenter size-large wp-image-1915" src="{{ site.baseurl }}/assets/images/&#4361;&#4467;&#4367;&#4467;&#4357;&#4469;&#4523;&#4361;&#4451;&#4538;-2016-06-04-&#4363;&#4457;&#4364;&#4453;&#4523;-10.43.32-1024x119.png" alt="스크린샷 2016-06-04 오전 10.43.32" width="960" height="112" /></a></div>
<p>어디보자… 어라 이게 뭐지? 웬 테스트 파일에 대한 커버리지가 떡하니 자리 잡고 있는 걸까? 원했던 건 실제 구현 코드에 대한 커버리지였는데. 심지어 개별 파일의 상세 리포트를 열어보면 트랜스파일 이후의 코드를 보여준다.</p>
<div><a href="http://huns.me/wp/wp-content/uploads/2016/06/스크린샷-2016-06-04-오후-12.13.44.png"><img class="aligncenter size-large wp-image-1919" src="{{ site.baseurl }}/assets/images/&#4361;&#4467;&#4367;&#4467;&#4357;&#4469;&#4523;&#4361;&#4451;&#4538;-2016-06-04-&#4363;&#4457;&#4370;&#4462;-12.13.44-1024x533.png" alt="스크린샷 2016-06-04 오후 12.13.44" width="960" height="500" /></a></div>
<p>&nbsp;</p>
<h2 class="se_textarea">isparta-loader로 커버리지 보정</h2>
<div>
<p>이게 이후의 꽤나 귀찮은 설정을 추가해야 하는 이유다. 내가 삽질하면서 시간을 보낸 이유기도 하고. karma.conf.js에 있는 아래 설정을 기억하는가?</p>
</div>
<div>
<pre class="lang:js decode:true">files: [
      './src/**/__tests__/*-test.js'
    ],</pre>
</div>
<p>이전에 언급했듯이 webpack은 진입점을 기준으로 의존성을 분석해서 코드를 트랜스파일한다. 일반 빌드 환경에서는 실제 구현 코드인 엔트리 파일이 진입점이지만, 테스트 환경에서는 테스트 파일을 진입점으로 잡는다. 따라서 실제 구현 코드가 아닌 테스트 코드가 커버리지 측정의 기준이 되어버린 셈이다. 이 문제를 해결할 방법을 찾는다고 삽집을 좀 많이 했는데, 내가 찾아 본 방법 중에<span class="Apple-converted-space"> </span><a href="https://github.com/deepsweet/isparta-loader">isparta-loader</a><span class="Apple-converted-space"> </span>전처리기를 이용하는 게 가장 깔끔했다. isparta-loader는 isparta를 webpack에 로더로 추가할 수 있는 인터페이스를 제공하는 모듈이다.</p>
<p>그렇다면<span class="Apple-converted-space"> </span><a href="https://github.com/douglasduteil/isparta">isparta</a>는 뭔가? isparta는 karma를 이용할 때 babel로 트랜스파일한 es2015 코드를 대상으로 테스트 커버리지를 측정하는 전처리를 수행할 목적으로 만든 도구다. 한 마디로 isparta를 이용하면 트랜스파일 전 코드를 대상으로 커버리지를 측정할 수 있고, 그걸 webpack에 껴 넣을 수 있는 로더가 isparta-loader다. 세상에는 참 훌륭한 능력자들이 많고 그들이 있어 험한 길이 조금 덜 괴롭다.</p>
<p>말이 많았으니 얼른 isparta-loader를 설치하자. 역시나 npm 패키지다.</p>
<div>
<pre class="lang:sh decode:true">npm install --save-dev isparta-loader</pre>
</div>
<div class="se_component se_paragraph default">
<div class="se_sectionArea">
<div class="se_editArea">
<div class="se_viewArea se_ff_nanumgothic">
<div class="se_editView">
<div class="se_textView se_fs_T3">
<p class="se_textarea">isparta-loader 설정을 webpack.config.js에 preloader로 추가해야 하는데,  커버리지를 측정할 때만 필요한 전처리이므로 단순 단위 테스트 실행 시에는 이 설정이 필요 없다. 테스트 로딩 속도만 떨어뜨릴 뿐이다. karma.conf.js에서 webpack 관련 설정을 위로 올려서 분기하자.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<pre class="lang:js decode:true">'use strict';
 
module.exports = function (config) {
    let browsers = ['Chrome'];
    let reporters = ['mocha'];
    let preprocessors = ['webpack', 'sourcemap'];
    let webpack = {
        devtool: 'inline-source-map',
        module: {
            loaders: [
                {
                    test: /(\.js)$/,
                    exclude: /(node_modules)/,
                    loader: ['babel-loader'],
                    query: {
                        presets: ['es2015']
                    }
                }
            ]
        }
    };
 
    if (config.coverage) {
        browsers = ['PhantomJS'];
        reporters = ['mocha', 'coverage'];
        preprocessors = ['webpack'];
        webpack.isparta = {
            embedSource: true,
            noAutoWrap: true,
            babel: {
                presets: ['es2015']
            }
        };
        webpack.module.preLoaders = [
            {
                test: /(\.js)$/,
                exclude: /(__tests__|node_modules)/,
                loader: 'isparta'
            }
        ];
    }
 
    config.set({
        browsers,
        reporters,
        webpack,
        frameworks: ['mocha'],
        files: [
            "./src/**/__tests__/*-test.js"
        ],
        plugins: [
            'karma-chrome-launcher',
            'karma-chai',
            'karma-mocha',
            'karma-sourcemap-loader',
            'karma-webpack',
            'karma-mocha-reporter',
            'karma-coverage',
            'karma-phantomjs-launcher'
        ],
        preprocessors: {
            './src/**/__tests__/*-test.js': preprocessors
        },
        coverageReporter: {
            type: 'html',
            dir: 'coverage'
        },
        webpackMiddleware: {
            noInfo: true //please don't spam the console when running in karma!
        },
        singleRun: config.coverage
    });
};</pre>
</div>
<p>다시 커버리지 리포트를 생성해서 열어본다. 테스트 파일이 커버리지 측정 대상에서 사라진 것을 확인할 수 있다.</p>
<div><a href="http://huns.me/wp/wp-content/uploads/2016/06/스크린샷-2016-06-04-오후-12.06.43.png"><img class="aligncenter size-large wp-image-1918" src="{{ site.baseurl }}/assets/images/&#4361;&#4467;&#4367;&#4467;&#4357;&#4469;&#4523;&#4361;&#4451;&#4538;-2016-06-04-&#4363;&#4457;&#4370;&#4462;-12.06.43-1024x144.png" alt="스크린샷 2016-06-04 오후 12.06.43" width="960" height="135" /></a></div>
<p>그리고 커버리지 리포트의 fibonacci.js 파일을 열어보면 트랜스 파일 이전 코드를 대상으로 커버리지를 측정했음을 알 수 있다. 훨씬 더 쾌적해졌다.</p>
<div><a href="http://huns.me/wp/wp-content/uploads/2016/06/스크린샷-2016-06-04-오후-12.06.03.png"><img class="aligncenter size-large wp-image-1917" src="{{ site.baseurl }}/assets/images/&#4361;&#4467;&#4367;&#4467;&#4357;&#4469;&#4523;&#4361;&#4451;&#4538;-2016-06-04-&#4363;&#4457;&#4370;&#4462;-12.06.03-1024x362.png" alt="스크린샷 2016-06-04 오후 12.06.03" width="960" height="339" /></a></div>
<p>&nbsp;</p>
<h2>끝으로...</h2>
<p>세상사가 다 그렇겠지만 얻는 게 있으면 잃는 게 있다. es2015의 도입도 그렇다. 디버깅 환경과 테스트 환경 구축의 복잡함은 잃은 것에 속한다. 설치하고 설정해야 할 것들도 많고, 그마저도 자연스러운 느낌은 아니다. 하지만 세상에는 능력자들이 많고, 그들의 노력으로 세상이 조금씩 나아지고 있기에 조만간 더 좋은 도구가 나와 우리를 이롭게 하기를 기대한다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>전체 과정을 수행한 예제 코드를 누군든지 확인할 수 있게 github에 올려놓았습니다. 더 좋은 생각이 있다면 어떤 의견도 들을 생각이 있으니, 주저하지 말고 이슈 게시판이나 댓글로 의견 주세요.  이 글은 <a href="http://blog.naver.com/jukrang/220727601620">네이버 블로그</a>에서도 보실 수 있습니다.</p>
<p>&nbsp;</p>
<div> <a href="https://github.com/CoderK/es2015-test-coverage-example">https://github.com/CoderK/es2015-test-coverage-example</a></div>
<div></div>

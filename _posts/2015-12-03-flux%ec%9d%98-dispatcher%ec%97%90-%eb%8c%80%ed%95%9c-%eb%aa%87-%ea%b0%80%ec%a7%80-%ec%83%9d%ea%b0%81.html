---
layout: post
title: Flux의 Dispatcher에 대한 몇 가지 생각
date: 2015-12-03 13:42:09.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- 개발 이야기
tags:
- dispatcher
- flux
meta:
  asalah_show_meta: '0'
  _edit_last: '1'
  sociallikes: '1'
  sociallikes_img_url: ''
  _et_post_bg_color: "#ffffff"
  _et_post_bg_layout: dark
  _format_video_embed: ''
  _format_quote_source_name: ''
  _format_quote_source_url: ''
  _format_gallery_type: shortcode
  _oembed_time_2af44e599edcdeab63f8726e68988176: '1482804179'
  _format_gallery_shortcode: ''
  asalah_sidebar_position: '0'
  asalah_custom_description: ''
  show_author_box: '0'
  asalah_show_title: '0'
  asalah_show_share: '0'
  _format_audio_embed: ''
  _oembed_2af44e599edcdeab63f8726e68988176: '<blockquote data-secret="RUhj7PRD0I"
    class="wp-embedded-content"><a href="http://huns.me/development/1953">리덕스(Redux)
    애플리케이션  설계에 대한 생각</a></blockquote><iframe class="wp-embedded-content" sandbox="allow-scripts"
    security="restricted" style="position: absolute; clip: rect(1px, 1px, 1px, 1px);"
    src="http://huns.me/development/1953/embed#?secret=RUhj7PRD0I" data-secret="RUhj7PRD0I"
    width="600" height="338" title="&#8220;리덕스(Redux) 애플리케이션  설계에 대한 생각&#8221; &#8212;
    Huns.me" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe>'
author:
  login: jeokrang
  email: jeokrang@gmail.com
  display_name: 개발왕 김코딩
  first_name: 훈민
  last_name: 김
permalink: "/development/1734"
excerpt: "\n\t\t\t\t\t\t"
---
<p>
				<span style="font-size: 10pt;">이 글에서 고민하던 내용은 대부분 리덕스를 도입하면서 해결한 듯.</span></p>
<p>http://huns.me/development/1953</p>
<p>&nbsp;</p>
<hr />
<p>자기 전에 누워서 뒹굴며 Flux 공식 문서랑 코드 살펴보고 새로 습득한 사실을 기록한다. 시간 날 때 뜯어보면서 내용을 계속 업데이트 할 예정이다.</p>
<p>&nbsp;</p>
<p>1.  Dispatcher를 만든 이유 중 하나는 Store간 의존성 관리</p>
<p>&nbsp;</p>
<p>2.  Store에서 Dispatcher에 콜백을 등록하는 이유는 크게 두 가지. 첫 번째는 Store와 Action 사이의 결합도를 약하게 만들기 위해서이고, 두 번째는 Action과 Store의 관계가 1:N일 때 호출 순서를 보장하기 위해서. Dispatcher.register를 이용해서 콜백을 등록하면 토큰을 돌려주고 이 토큰을 waitFor 메서드에 전달해서 의존하는 Store A의 처리가 끝날 때까지 Store B의 실행을 지연시킨다. 토큰은 Dispatcher에 저장한 콜백 함수의 인덱스다. 그래서 Flux는 정책적으로 Store마다 콜백을 하나씩 등록해서 토큰으로 관리할 것을 권장한다.</p>
<p><a href="https://facebook.github.io/flux/docs/dispatcher.html">https://facebook.github.io/flux/docs/dispatcher.html</a></p>
<p>근데 XHR 요청 같은 비동기 처리는 어쩐다? Promise는?</p>
<p>&nbsp;</p>
<p>3. flux-utils에는 FluxStoreGroup이라는 녀석이 들어갔다. 2번과 관련이 있는 것 같다. 얘를 좀 더 봐야겠다.</p>
<p><a href="https://github.com/facebook/flux/blob/master/src/FluxStoreGroup.js">https://github.com/facebook/flux/blob/master/src/FluxStoreGroup.js</a></p>
<p>&nbsp;</p>
<p>4. waitFor가 잘 안 알려진 이유는 아마도 Todo 예제에서 사용하지 않아서가 아닐까?</p>
<p>&nbsp;</p>
<p>5. 구글링을 해봤는데 Flux를 접하는 많은 사람이 DataSource 접근 로직을 어디에 둬야하는지 헷갈려한다. 애매하다.</p>
<p>&nbsp;</p>
<p>6.  굳이 억지로 막 껴넣자면 MVC보다는 MVI가 더 어울리는 구조. Action에서 의도를 던지면 의도(Intend)를 이해하는 Store가 받아 먹는다. Dispatcher는 Action을 전파하는 브로드 캐스터의 역할도 한다. Action을 수정하지 않고도 Store를 확장할 수 있어 개방-폐쇄 원칙을 지킬 수 있는 장점이 있다. 하지만 <strong>"Component -&gt; Action -&gt; Store"</strong> 순으로 명령을 전달하는 전체 과정 중에 Action에서 Store로 명령을 전달하는 과정이 코드 상에서 명시적으로 보이지 않는다는 단점이 있다.  Action이 어떤 Store와 관계를 맺는지 Action만 봐서는 알 수 없다.</p>
<p>&nbsp;</p>
<p>7. Store 관리 정책, Dispatcher 구현 전략에 따라 다양한 flux 구현체가 나온다. 데이터와 UI의 상태를 동기화하는 방법에 따라 다양한 변종이 나오는 MVC랑 같다. 그냥 큰 틀에서 MVC의 새로운 변종 정도로 볼 수 있을 거 같은데 redux를 자세히 보지 않아서 결론은 잠시 뒤로.</p>
<p>&nbsp;</p>
<p>8. 애플리케이션의 전역 상태와 영속성을 가져야 하는 상태를 어떻게 관리하는 게 좋을지 아직 잘 모르겠다.</p>
<p>&nbsp;</p>
<p>9. React 애플리케이션을 만들다보면 Store에 상대적으로 많은 코드가 많이 몰리는 느낌이다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;		</p>
